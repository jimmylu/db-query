// Cross-Database Query Models
//
// Models for cross-database JOIN and UNION queries using DataFusion's federated execution.

use serde::{Deserialize, Serialize};
use chrono::{DateTime, Utc};
use std::collections::HashMap;

/// Request for cross-database query execution
///
/// Allows querying multiple databases in a single SQL statement using qualified table names.
///
/// # Examples
///
/// ```
/// // JOIN MySQL and PostgreSQL with aliases
/// let mut aliases = HashMap::new();
/// aliases.insert("db1".to_string(), "mysql-conn-id".to_string());
/// aliases.insert("db2".to_string(), "pg-conn-id".to_string());
///
/// let request = CrossDatabaseQueryRequest {
///     query: "SELECT u.username, t.title FROM db1.users u JOIN db2.todos t ON u.id = t.user_id".to_string(),
///     connection_ids: vec!["mysql-conn-id".to_string(), "pg-conn-id".to_string()],
///     database_aliases: Some(aliases),
///     timeout_secs: Some(60),
///     apply_limit: Some(true),
///     limit_value: Some(100),
/// };
/// ```
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CrossDatabaseQueryRequest {
    /// SQL query with qualified table names (e.g., db1.table1, db2.table2)
    ///
    /// Table qualification format: `<database_identifier>.<table_name>`
    /// The database identifier must map to one of the connection_ids or aliases
    pub query: String,

    /// List of connection IDs involved in the query
    ///
    /// Each connection ID must exist and be accessible by the user
    pub connection_ids: Vec<String>,

    /// Optional database aliases mapping (e.g., {"db1": "uuid-1", "db2": "uuid-2"})
    ///
    /// Allows using simple aliases like "db1", "db2" in queries instead of UUIDs
    /// If not provided, connection IDs are used directly (not recommended for UUIDs)
    #[serde(skip_serializing_if = "Option::is_none")]
    pub database_aliases: Option<HashMap<String, String>>,

    /// Query timeout in seconds (default: 60)
    ///
    /// This is the total timeout for the entire cross-database operation,
    /// including all sub-queries and result merging
    #[serde(skip_serializing_if = "Option::is_none")]
    pub timeout_secs: Option<u64>,

    /// Whether to automatically apply LIMIT if not present (default: true)
    ///
    /// For safety, cross-database queries should have limits to prevent
    /// excessive data transfer across databases
    #[serde(skip_serializing_if = "Option::is_none")]
    pub apply_limit: Option<bool>,

    /// LIMIT value to apply (default: 1000)
    ///
    /// This limit is applied to the final result set after merging
    #[serde(skip_serializing_if = "Option::is_none")]
    pub limit_value: Option<u32>,
}

/// Response from cross-database query execution
///
/// Contains the original query, sub-queries executed per database,
/// and the merged results
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CrossDatabaseQueryResponse {
    /// Original cross-database SQL query
    pub original_query: String,

    /// Sub-queries executed against each database
    ///
    /// Shows how the original query was decomposed and executed
    pub sub_queries: Vec<SubQueryExecution>,

    /// Final merged results as JSON objects
    pub results: Vec<serde_json::Value>,

    /// Total number of rows in the final result set
    pub row_count: usize,

    /// Total execution time in milliseconds
    ///
    /// Includes sub-query execution time and merging time
    pub execution_time_ms: u128,

    /// Whether LIMIT was automatically applied
    pub limit_applied: bool,

    /// Timestamp when query was executed
    #[serde(with = "chrono::serde::ts_milliseconds")]
    pub executed_at: DateTime<Utc>,
}

/// Information about a sub-query executed against a specific database
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SubQueryExecution {
    /// Connection ID where this sub-query was executed
    pub connection_id: String,

    /// Database type (mysql, postgresql, etc.)
    pub database_type: String,

    /// The SQL query sent to this database
    ///
    /// This is the decomposed sub-query specific to this database
    pub query: String,

    /// Number of rows returned by this sub-query
    pub row_count: usize,

    /// Execution time for this specific sub-query in milliseconds
    pub execution_time_ms: u128,
}

/// Internal: Cross-database execution plan
///
/// Generated by CrossDatabaseQueryPlanner, consumed by FederatedExecutor
#[derive(Debug, Clone)]
pub struct CrossDatabaseExecutionPlan {
    /// Original query
    pub original_query: String,

    /// Sub-queries to execute per database
    pub sub_queries: Vec<SubQuery>,

    /// How to merge the sub-query results
    pub merge_strategy: MergeStrategy,

    /// Timeout for the entire operation
    pub timeout_secs: u64,

    /// Whether to apply LIMIT to final results
    pub apply_limit: bool,

    /// LIMIT value
    pub limit_value: u32,
}

/// Internal: A sub-query to execute against a specific database
#[derive(Debug, Clone)]
pub struct SubQuery {
    /// Connection ID
    pub connection_id: String,

    /// Database type
    pub database_type: String,

    /// SQL query for this database
    pub query: String,

    /// Tables referenced from this database
    pub tables: Vec<String>,

    /// Alias for this sub-query result
    ///
    /// Used when registering as in-memory table in DataFusion
    pub result_alias: String,
}

/// Internal: Strategy for merging sub-query results
#[derive(Debug, Clone)]
pub enum MergeStrategy {
    /// Inner JOIN between two or more databases
    InnerJoin {
        /// JOIN conditions (e.g., "left.id = right.user_id")
        conditions: Vec<JoinCondition>,
    },

    /// Left JOIN
    LeftJoin {
        conditions: Vec<JoinCondition>,
    },

    /// UNION (or UNION ALL) results
    Union {
        /// Whether to use UNION ALL (keep duplicates)
        all: bool,
    },

    /// No merging needed (single database query)
    None,
}

/// Internal: JOIN condition between tables from different databases
#[derive(Debug, Clone)]
pub struct JoinCondition {
    /// Left table result alias
    pub left_alias: String,

    /// Left column name
    pub left_column: String,

    /// Right table result alias
    pub right_alias: String,

    /// Right column name
    pub right_column: String,
}

impl CrossDatabaseQueryRequest {
    /// Create a new cross-database query request
    pub fn new(query: String, connection_ids: Vec<String>) -> Self {
        Self {
            query,
            connection_ids,
            database_aliases: None,
            timeout_secs: Some(60), // Default 60 seconds
            apply_limit: Some(true),
            limit_value: Some(1000),
        }
    }

    /// Create a new cross-database query request with aliases
    pub fn with_aliases(
        query: String,
        connection_ids: Vec<String>,
        aliases: HashMap<String, String>,
    ) -> Self {
        Self {
            query,
            connection_ids,
            database_aliases: Some(aliases),
            timeout_secs: Some(60),
            apply_limit: Some(true),
            limit_value: Some(1000),
        }
    }

    /// Validate the request
    ///
    /// Checks:
    /// - Query is not empty
    /// - At least 1 connection ID provided
    /// - Timeout is reasonable
    /// - Limit value is reasonable
    pub fn validate(&self) -> Result<(), String> {
        if self.query.trim().is_empty() {
            return Err("Query cannot be empty".to_string());
        }

        if self.connection_ids.is_empty() {
            return Err("At least one connection ID is required".to_string());
        }

        if let Some(timeout) = self.timeout_secs {
            if timeout == 0 || timeout > 300 {
                return Err("Timeout must be between 1 and 300 seconds".to_string());
            }
        }

        if let Some(limit) = self.limit_value {
            if limit == 0 || limit > 10000 {
                return Err("Limit must be between 1 and 10000".to_string());
            }
        }

        Ok(())
    }
}

impl CrossDatabaseQueryResponse {
    /// Create a new response
    pub fn new(
        original_query: String,
        sub_queries: Vec<SubQueryExecution>,
        results: Vec<serde_json::Value>,
        execution_time_ms: u128,
        limit_applied: bool,
    ) -> Self {
        let row_count = results.len();

        Self {
            original_query,
            sub_queries,
            results,
            row_count,
            execution_time_ms,
            limit_applied,
            executed_at: Utc::now(),
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_cross_database_request_validation() {
        // Valid request with 2 connections
        let request = CrossDatabaseQueryRequest::new(
            "SELECT * FROM db1.users JOIN db2.orders ON users.id = orders.user_id".to_string(),
            vec!["conn1".to_string(), "conn2".to_string()],
        );
        assert!(request.validate().is_ok());

        // Valid request with 1 connection (single database)
        let request = CrossDatabaseQueryRequest::new(
            "SELECT * FROM users".to_string(),
            vec!["conn1".to_string()],
        );
        assert!(request.validate().is_ok());

        // Invalid: empty query
        let request = CrossDatabaseQueryRequest::new(
            "".to_string(),
            vec!["conn1".to_string(), "conn2".to_string()],
        );
        assert!(request.validate().is_err());

        // Invalid: no connections
        let request = CrossDatabaseQueryRequest::new(
            "SELECT * FROM users".to_string(),
            vec![],
        );
        assert!(request.validate().is_err());

        // Invalid: timeout too high
        let mut request = CrossDatabaseQueryRequest::new(
            "SELECT * FROM db1.users".to_string(),
            vec!["conn1".to_string(), "conn2".to_string()],
        );
        request.timeout_secs = Some(500);
        assert!(request.validate().is_err());
    }

    #[test]
    fn test_cross_database_response_creation() {
        let response = CrossDatabaseQueryResponse::new(
            "SELECT * FROM db1.users JOIN db2.orders ON users.id = orders.user_id".to_string(),
            vec![
                SubQueryExecution {
                    connection_id: "conn1".to_string(),
                    database_type: "mysql".to_string(),
                    query: "SELECT id, username FROM users".to_string(),
                    row_count: 10,
                    execution_time_ms: 5,
                },
                SubQueryExecution {
                    connection_id: "conn2".to_string(),
                    database_type: "postgresql".to_string(),
                    query: "SELECT id, user_id, total FROM orders".to_string(),
                    row_count: 25,
                    execution_time_ms: 8,
                },
            ],
            vec![serde_json::json!({"username": "alice", "total": 100})],
            25,
            false,
        );

        assert_eq!(response.row_count, 1);
        assert_eq!(response.sub_queries.len(), 2);
        assert_eq!(response.execution_time_ms, 25);
    }
}

# Data Model: Database Query Tool

**Date**: 2024-12-22  
**Feature**: Database Query Tool

## Overview

This document defines the core data entities and their relationships for the database query tool. Entities are described at a conceptual level without implementation details.

## Core Entities

### DatabaseConnection

Represents a connection to an external database.

**Attributes**:
- `id` (string, unique): Unique identifier for the connection
- `name` (string, optional): User-friendly name for the connection
- `connection_url` (string): Database connection URL (e.g., `postgresql://user:pass@host:5432/dbname`)
- `database_type` (string): Type of database (e.g., "postgresql", "mysql")
- `status` (enum): Connection status - `connected`, `disconnected`, `error`
- `created_at` (timestamp): When the connection was first created
- `last_connected_at` (timestamp, optional): Last successful connection time
- `metadata_cache_id` (string, optional): Reference to cached metadata

**Relationships**:
- Has one DatabaseMetadata (cached metadata)
- Has many Query (query execution history)

**Validation Rules**:
- `connection_url` must be a valid database URL format
- `database_type` must be supported (initially: "postgresql")
- `name` is optional but recommended for user experience

**State Transitions**:
- `disconnected` → `connected`: On successful connection
- `connected` → `disconnected`: On connection close or timeout
- `connected` → `error`: On connection failure
- `error` → `disconnected`: On error recovery

### DatabaseMetadata

Represents cached metadata about a database structure.

**Attributes**:
- `id` (string, unique): Unique identifier for metadata cache
- `connection_id` (string): Reference to DatabaseConnection
- `tables` (array of Table): List of tables in the database
- `views` (array of View): List of views in the database
- `schemas` (array of string): List of schema names
- `metadata_json` (string): JSON representation of metadata (for LLM context)
- `retrieved_at` (timestamp): When metadata was last retrieved
- `version` (integer): Version number for cache invalidation

**Relationships**:
- Belongs to one DatabaseConnection
- Contains many Table
- Contains many View

**Validation Rules**:
- `metadata_json` must be valid JSON
- `retrieved_at` must be set when metadata is retrieved
- `version` increments on each metadata refresh

**Storage**:
- Stored in SQLite database
- JSON format for LLM context generation
- Cached to avoid repeated database introspection

### Table

Represents a database table.

**Attributes**:
- `name` (string): Table name
- `schema` (string, optional): Schema name (default: "public" for PostgreSQL)
- `columns` (array of Column): List of columns in the table
- `row_count` (integer, optional): Approximate row count (if available)
- `description` (string, optional): Table description/comment

**Relationships**:
- Belongs to one DatabaseMetadata
- Has many Column

**Validation Rules**:
- `name` must be non-empty
- `columns` array must not be empty

### View

Represents a database view.

**Attributes**:
- `name` (string): View name
- `schema` (string, optional): Schema name (default: "public" for PostgreSQL)
- `columns` (array of Column): List of columns in the view
- `definition` (string, optional): SQL definition of the view
- `description` (string, optional): View description/comment

**Relationships**:
- Belongs to one DatabaseMetadata
- Has many Column

**Validation Rules**:
- `name` must be non-empty
- `columns` array must not be empty

### Column

Represents a column in a table or view.

**Attributes**:
- `name` (string): Column name
- `data_type` (string): SQL data type (e.g., "VARCHAR", "INTEGER", "TIMESTAMP")
- `is_nullable` (boolean): Whether column allows NULL values
- `is_primary_key` (boolean): Whether column is part of primary key
- `is_foreign_key` (boolean): Whether column is a foreign key
- `default_value` (string, optional): Default value for the column
- `max_length` (integer, optional): Maximum length for string types
- `description` (string, optional): Column description/comment

**Relationships**:
- Belongs to one Table or View

**Validation Rules**:
- `name` must be non-empty
- `data_type` must be a valid SQL type

### Query

Represents a SQL query execution.

**Attributes**:
- `id` (string, unique): Unique identifier for the query execution
- `connection_id` (string): Reference to DatabaseConnection
- `query_text` (string): The SQL query text
- `is_llm_generated` (boolean): Whether query was generated by LLM
- `status` (enum): Execution status - `pending`, `executing`, `completed`, `failed`
- `results` (array of object, optional): Query results (JSON array of row objects)
- `row_count` (integer, optional): Number of rows returned
- `execution_time_ms` (integer, optional): Query execution time in milliseconds
- `error_message` (string, optional): Error message if execution failed
- `executed_at` (timestamp, optional): When query was executed
- `limit_applied` (boolean): Whether LIMIT 1000 was auto-appended

**Relationships**:
- Belongs to one DatabaseConnection

**Validation Rules**:
- `query_text` must be non-empty
- `query_text` must be valid SELECT statement (validated by SQLParser)
- `status` must be one of the defined enum values
- `results` only present when `status` is `completed`

**State Transitions**:
- `pending` → `executing`: When query starts execution
- `executing` → `completed`: On successful execution
- `executing` → `failed`: On execution error
- `pending` → `failed`: On validation failure

## Data Flow

### Connection Flow

1. User provides connection URL
2. System creates DatabaseConnection entity (status: `disconnected`)
3. System attempts connection
4. On success: status → `connected`, retrieve metadata
5. System creates/updates DatabaseMetadata
6. Metadata converted to JSON via LLM
7. Metadata stored in SQLite

### Query Execution Flow

1. User provides SQL query text
2. System creates Query entity (status: `pending`)
3. System validates query using SQLParser
4. If invalid: status → `failed`, set error_message
5. If valid: check for LIMIT clause
6. If missing LIMIT: append `LIMIT 1000`, set `limit_applied = true`
7. Status → `executing`
8. Execute query against database
9. On success: status → `completed`, store results
10. On error: status → `failed`, set error_message

### Natural Language Query Flow

1. User provides natural language question
2. System retrieves DatabaseMetadata for connection
3. System extracts `metadata_json` from DatabaseMetadata
4. System sends natural language + metadata_json to LLM service
5. LLM generates SQL query
6. System creates Query entity with `is_llm_generated = true`
7. Continue with Query Execution Flow (step 3+)

## Storage Schema

### SQLite Tables (Metadata Storage)

**connections**:
- id (TEXT PRIMARY KEY)
- name (TEXT)
- connection_url (TEXT NOT NULL)
- database_type (TEXT NOT NULL)
- status (TEXT NOT NULL)
- created_at (TIMESTAMP NOT NULL)
- last_connected_at (TIMESTAMP)
- metadata_cache_id (TEXT)

**metadata_cache**:
- id (TEXT PRIMARY KEY)
- connection_id (TEXT NOT NULL)
- metadata_json (TEXT NOT NULL)
- retrieved_at (TIMESTAMP NOT NULL)
- version (INTEGER NOT NULL)

**query_history** (optional, for future enhancement):
- id (TEXT PRIMARY KEY)
- connection_id (TEXT NOT NULL)
- query_text (TEXT NOT NULL)
- is_llm_generated (BOOLEAN NOT NULL)
- executed_at (TIMESTAMP NOT NULL)
- execution_time_ms (INTEGER)

## Constraints and Business Rules

1. **One metadata cache per connection**: Each DatabaseConnection has at most one active DatabaseMetadata
2. **Query validation required**: All queries must pass SQLParser validation before execution
3. **SELECT only**: Only SELECT statements are permitted (enforced by SQLParser)
4. **LIMIT enforcement**: All queries must have LIMIT clause (auto-appended if missing)
5. **JSON results**: All query results must be in JSON format (array of objects)
6. **Metadata freshness**: Metadata can be refreshed manually; cached version used by default
7. **Connection isolation**: Each connection maintains separate metadata cache

## Future Enhancements

- Query history persistence (currently in-memory)
- Metadata refresh scheduling (automatic refresh on TTL)
- Connection pooling for multiple queries
- Query result caching
- User preferences storage
- Multiple database type support (MySQL, SQLite, etc.)

